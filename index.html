<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#0f172a" />
    <!-- Content Security Policy: Allow inline scripts and styles for this standalone app -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; style-src * 'unsafe-inline';">
    <title>Neon Tactical Shooter</title>
    
    <!-- React 18 & Babel Standalone (UMD) -->
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root {
        --color-blue: #3b82f6;
        --color-purple: #9333ea;
        --color-red: #ef4444;
        --color-slate-900: #0f172a;
        --color-slate-800: #1e293b;
        --color-slate-500: #64748b;
        --color-slate-400: #94a3b8;
        --color-slate-200: #e2e8f0;
        --color-slate-100: #f1f5f9;
        --color-white: #ffffff;
      }

      body {
        margin: 0;
        overflow: hidden;
        background-color: var(--color-slate-900);
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        color: var(--color-slate-800);
      }

      .full-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
      .z-0 { z-index: 0; }
      .z-10 { z-index: 10; }
      .z-20 { z-index: 20; }
      .z-30 { z-index: 30; }
      .pointer-events-none { pointer-events: none; }
      
      /* HUD */
      .hud-container {
        position: absolute; top: 0; left: 0; width: 100%; padding: 1rem;
        display: flex; justify-content: space-between; align-items: flex-start;
        box-sizing: border-box;
      }
      .hud-panel, .hud-badge {
        background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
        padding: 0.75rem 1rem; border-radius: 0.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      }
      .hud-panel { border-left: 4px solid var(--color-blue); }
      .text-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: var(--color-slate-500); font-weight: 700; display: block; margin-bottom: 0.25rem; }
      .text-score { font-size: 1.875rem; font-weight: 900; color: var(--color-slate-800); line-height: 1; font-variant-numeric: tabular-nums; }

      /* Menus */
      .menu-overlay {
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(4px);
        animation: fadeIn 0.5s ease-out;
      }
      .menu-content { width: 100%; max-width: 28rem; padding: 0 1.5rem; display: flex; flex-direction: column; align-items: center; box-sizing: border-box; }
      .icon-circle { margin-bottom: 0.5rem; padding: 0.75rem; background-color: var(--color-slate-100); border-radius: 9999px; display: flex; align-items: center; justify-content: center; }
      .title-text { font-size: 2.25rem; font-weight: 900; margin-bottom: 0.5rem; letter-spacing: -0.025em; text-align: center; transition: color 0.3s; }
      .subtitle-text { color: var(--color-slate-500); margin-bottom: 2rem; letter-spacing: 0.1em; font-size: 0.875rem; font-weight: 500; text-transform: uppercase; text-align: center; }

      /* Difficulty Buttons */
      .difficulty-list { width: 100%; margin-bottom: 2rem; display: flex; flex-direction: column; gap: 0.75rem; }
      .difficulty-btn {
        width: 100%; display: flex; align-items: center; justify-content: space-between;
        padding: 1rem; border-radius: 0.75rem; border: 2px solid var(--color-slate-200);
        background: var(--color-white); cursor: pointer; transition: all 0.2s; box-sizing: border-box;
      }
      .difficulty-btn:hover { border-color: #cbd5e1; }
      .difficulty-btn.selected { transform: scale(1.02); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
      .diff-content { display: flex; align-items: center; gap: 0.75rem; }
      .diff-text-group { text-align: left; }
      .diff-name { font-weight: 700; font-size: 0.875rem; color: var(--color-slate-500); }
      .difficulty-btn.selected .diff-name { color: var(--color-slate-900); }
      .diff-desc { font-size: 0.75rem; color: var(--color-slate-400); font-weight: 500; }

      /* Buttons */
      .btn-primary {
        width: 100%; padding: 1rem; border-radius: 9999px; color: white; font-weight: 700; font-size: 1.125rem;
        display: flex; align-items: center; justify-content: center; gap: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); transition: all 0.2s; border: none; cursor: pointer;
        background-color: var(--color-slate-900);
      }
      .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.15); }
      .btn-secondary {
        padding: 0.75rem 2rem; color: var(--color-slate-500); font-weight: 700; background: transparent;
        border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: color 0.2s;
      }
      .btn-secondary:hover { color: var(--color-slate-800); }

      /* Game Over */
      .gameover-card {
        background: white; padding: 1.5rem; border-radius: 1rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1); border: 1px solid var(--color-slate-100);
        margin-bottom: 2rem; min-width: 280px; text-align: center;
      }
      .gameover-title { font-size: 3rem; font-weight: 900; color: var(--color-red); margin-bottom: 0.5rem; letter-spacing: -0.05em; line-height: 1; }
      .score-row { margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--color-slate-100); display: flex; justify-content: space-between; align-items: center; }

      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useCallback } = React;

      // --- CONSTANTS ---
      const DIFFICULTIES = {
        EASY: {
          label: "RECRUIT",
          spawnRateBase: 80,
          bulletSpeedMult: 0.7,
          scoreMultiplier: 0.5,
          playerShotInterval: 14,
        },
        NORMAL: {
          label: "VETERAN",
          spawnRateBase: 65,
          bulletSpeedMult: 0.9,
          scoreMultiplier: 0.75,
          playerShotInterval: 10,
        },
        HARD: {
          label: "ELITE",
          spawnRateBase: 50,
          bulletSpeedMult: 1.2,
          scoreMultiplier: 0.9,
          playerShotInterval: 8,
        },
        IMPOSSIBLE: {
          label: "LEGEND",
          spawnRateBase: 40,
          bulletSpeedMult: 1.4,
          scoreMultiplier: 1.0, // Ensures accurate 200/100 points
          playerShotInterval: 6,
        }
      };

      const COLORS = {
        player: '#3b82f6',
        playerCore: '#ef4444',
        enemyTriangle: '#eab308',
        enemySquare: '#f97316',
        enemyPentagon: '#d946ef',
        enemyCircle: '#ef4444',
      };

      const PLAYER_SIZE = 12;
      const PLAYER_HIT_SIZE = 6;

      // --- GAME ENGINE COMPONENT ---
      const GameEngine = ({ gameState, difficulty, onGameOver, onScoreUpdate }) => {
        const canvasRef = useRef(null);
        const requestRef = useRef(null);
        
        // Game State Refs
        const scoreRef = useRef(0);
        const frameCountRef = useRef(0);
        const playerRef = useRef({ x: 0, y: 0 });
        const targetRef = useRef({ x: 0, y: 0 });
        
        const pBulletsRef = useRef([]);
        const enemiesRef = useRef([]);
        const eBulletsRef = useRef([]);
        const particlesRef = useRef([]);

        const resetGame = () => {
          if (!canvasRef.current) return;
          const canvas = canvasRef.current;
          scoreRef.current = 0;
          frameCountRef.current = 0;
          pBulletsRef.current = [];
          enemiesRef.current = [];
          eBulletsRef.current = [];
          particlesRef.current = [];
          playerRef.current = { x: canvas.width / 2, y: canvas.height - 100 };
          targetRef.current = { x: playerRef.current.x, y: playerRef.current.y };
          onScoreUpdate(0);
        };

        const createParticles = (x, y, color, count, speedMult = 1) => {
          for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 * speedMult;
            particlesRef.current.push({
              x, y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.0,
              color,
              size: Math.random() * 3 + 2
            });
          }
        };

        const fireEnemyBullet = (x, y, angle, speed, color) => {
          eBulletsRef.current.push({
            x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, color
          });
        };

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          const resize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (gameState === 'menu') {
              playerRef.current.x = canvas.width / 2;
              playerRef.current.y = canvas.height - 100;
              targetRef.current = { x: canvas.width / 2, y: canvas.height - 100 };
            }
          };
          window.addEventListener('resize', resize);
          resize();

          const handleInput = (cx, cy, isTouch) => {
            if (gameState !== 'playing') return;
            targetRef.current.x = cx;
            targetRef.current.y = isTouch ? cy - 70 : cy;
          };

          const onMouseMove = (e) => handleInput(e.clientX, e.clientY, false);
          const onTouchMove = (e) => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY, true); };
          const onTouchStart = (e) => { handleInput(e.touches[0].clientX, e.touches[0].clientY, true); };

          canvas.addEventListener('mousemove', onMouseMove);
          canvas.addEventListener('touchmove', onTouchMove, { passive: false });
          canvas.addEventListener('touchstart', onTouchStart, { passive: false });

          const loop = () => {
            if (!ctx || !canvas) return;
            
            // Clear
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
              const diffConfig = DIFFICULTIES[difficulty];
              frameCountRef.current++;

              // Dynamic Difficulty: Scaling Tier (Every 500 score)
              const scalingTier = Math.floor(scoreRef.current / 500);

              // Move Player
              const p = playerRef.current;
              const t = targetRef.current;
              p.x += (t.x - p.x) * 0.15;
              p.y += (t.y - p.y) * 0.15;
              p.x = Math.max(PLAYER_SIZE, Math.min(canvas.width - PLAYER_SIZE, p.x));
              p.y = Math.max(PLAYER_SIZE, Math.min(canvas.height - PLAYER_SIZE, p.y));

              // Player Shoot (Faster with scaling)
              const currentShotInterval = Math.max(4, diffConfig.playerShotInterval - scalingTier);
              if (frameCountRef.current % currentShotInterval === 0) {
                pBulletsRef.current.push({ x: p.x, y: p.y - 20 });
              }

              // Spawn Enemies (More frequent with scaling)
              const spawnReduction = scalingTier * 4;
              const currentSpawnRate = Math.max(10, diffConfig.spawnRateBase - spawnReduction);
              
              if (frameCountRef.current % currentSpawnRate === 0) {
                const rand = Math.random();
                let type = 'triangle';
                
                if (difficulty === 'EASY') {
                  type = rand < 0.6 ? 'triangle' : 'square';
                } else if (difficulty === 'NORMAL') {
                  if (rand < 0.15) type = 'pentagon';
                  else if (rand < 0.50) type = 'triangle';
                  else if (rand < 0.90) type = 'square';
                  else type = 'circle';
                } else if (difficulty === 'HARD') {
                  if (rand < 0.20) type = 'pentagon';
                  else if (rand < 0.50) type = 'triangle';
                  else if (rand < 0.85) type = 'square';
                  else type = 'circle';
                } else if (difficulty === 'IMPOSSIBLE') {
                  // Legend: Pink & Red Only
                  type = rand < 0.4 ? 'pentagon' : 'circle';
                }

                let hp, color, speed, scoreVal;
                // Unified HP: Yellow 1, Orange 5, Pink 6, Red 6
                switch(type) {
                  case 'triangle': hp=1; color=COLORS.enemyTriangle; speed=(canvas.height/180)+Math.random(); scoreVal=30; break;
                  case 'square':   hp=5; color=COLORS.enemySquare;   speed=(canvas.height/400)+Math.random(); scoreVal=50; break;
                  case 'pentagon': hp=6; color=COLORS.enemyPentagon; speed=(canvas.height/300)+Math.random(); scoreVal=100; break;
                  case 'circle':   hp=6; color=COLORS.enemyCircle;   speed=canvas.height/250;                 scoreVal=200; break;
                }

                enemiesRef.current.push({
                  x: Math.random() * (canvas.width - 40) + 20,
                  y: -40, type, hp, color, size: 18, speed, hasShot: false, scoreValue: scoreVal
                });
              }

              // Update Player Bullets
              for (let i = pBulletsRef.current.length - 1; i >= 0; i--) {
                const b = pBulletsRef.current[i];
                b.y -= 20;
                if (b.y < -20) pBulletsRef.current.splice(i, 1);
              }

              // Update Enemies
              for (let i = enemiesRef.current.length - 1; i >= 0; i--) {
                const e = enemiesRef.current[i];
                e.y += e.speed;

                // Enemy Shooting
                if (e.y > 0 && e.y < canvas.height) {
                  // Triangle/Square: Aimed
                  if ((e.type === 'triangle' || e.type === 'square') && !e.hasShot) {
                    const triggerY = e.type === 'triangle' ? canvas.height * 0.2 : canvas.height * 0.3;
                    if (e.y > triggerY) {
                      const angle = Math.atan2(p.y - e.y, p.x - e.x);
                      fireEnemyBullet(e.x, e.y, angle, 6 * diffConfig.bulletSpeedMult, e.color);
                      e.hasShot = true;
                    }
                  }
                  // Circle: Rapid Fire
                  if (e.type === 'circle' && frameCountRef.current % 40 === 0) {
                    const angle = Math.atan2(p.y - e.y, p.x - e.x);
                    fireEnemyBullet(e.x, e.y, angle, 7 * diffConfig.bulletSpeedMult, e.color);
                  }
                  // Pentagon: Spread
                  if (e.type === 'pentagon' && !e.hasShot) {
                    if (e.y > canvas.height * 0.25) {
                      e.hasShot = true;
                      const bulletCount = 12;
                      for (let k = 0; k < bulletCount; k++) {
                        const angle = (Math.PI * 2 / bulletCount) * k;
                        fireEnemyBullet(e.x, e.y, angle + (Date.now()/1000), 4 * diffConfig.bulletSpeedMult, e.color);
                      }
                      e.speed *= 0.5;
                    }
                  }
                }

                // Collision: Player vs Enemy
                if (Math.hypot(p.x - e.x, p.y - e.y) < PLAYER_HIT_SIZE + e.size) {
                  createParticles(p.x, p.y, COLORS.player, 50, 2);
                  onGameOver(Math.floor(scoreRef.current));
                  return;
                }

                // Collision: Player Bullet vs Enemy
                for (let j = pBulletsRef.current.length - 1; j >= 0; j--) {
                  const b = pBulletsRef.current[j];
                  if (Math.abs(b.x - e.x) < e.size + 10 && Math.abs(b.y - e.y) < e.size + 10) {
                    createParticles(e.x, e.y, e.color, 3);
                    pBulletsRef.current.splice(j, 1);
                    e.hp--;
                    if (e.hp <= 0) {
                      createParticles(e.x, e.y, e.color, 15, 1.5);
                      scoreRef.current += e.scoreValue * diffConfig.scoreMultiplier;
                      onScoreUpdate(Math.floor(scoreRef.current));
                      enemiesRef.current.splice(i, 1);
                      break;
                    }
                  }
                }
                if (e.y > canvas.height + 50) enemiesRef.current.splice(i, 1);
              }

              // Update Enemy Bullets
              for (let i = eBulletsRef.current.length - 1; i >= 0; i--) {
                const b = eBulletsRef.current[i];
                b.x += b.vx; b.y += b.vy;
                if (Math.hypot(p.x - b.x, p.y - b.y) < PLAYER_HIT_SIZE + 4) {
                  createParticles(p.x, p.y, COLORS.player, 50, 2);
                  onGameOver(Math.floor(scoreRef.current));
                  return;
                }
                if (b.x < -50 || b.x > canvas.width+50 || b.y > canvas.height+50 || b.y < -50) eBulletsRef.current.splice(i, 1);
              }

              // Update Particles
              for (let i = particlesRef.current.length - 1; i >= 0; i--) {
                const pt = particlesRef.current[i];
                pt.x += pt.vx; pt.y += pt.vy; pt.life -= 0.04;
                if (pt.life <= 0) particlesRef.current.splice(i, 1);
              }
            } // End playing

            // DRAW
            const p = playerRef.current;
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.arc(p.x, p.y+20, PLAYER_SIZE, 0, Math.PI*2); ctx.fill();
            // Player
            ctx.fillStyle = COLORS.player; ctx.beginPath();
            ctx.moveTo(p.x, p.y - PLAYER_SIZE*1.5); ctx.lineTo(p.x - PLAYER_SIZE, p.y + PLAYER_SIZE);
            ctx.lineTo(p.x, p.y + PLAYER_SIZE*0.5); ctx.lineTo(p.x + PLAYER_SIZE, p.y + PLAYER_SIZE);
            ctx.fill();
            // Core
            ctx.fillStyle = COLORS.playerCore; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill();

            // Player Bullets
            ctx.fillStyle = '#1e293b'; pBulletsRef.current.forEach(b => ctx.fillRect(b.x-2, b.y, 4, 15));

            // Enemies
            enemiesRef.current.forEach(e => {
              ctx.fillStyle = e.color;
              if (e.type === 'triangle') {
                ctx.beginPath(); ctx.moveTo(e.x, e.y+e.size); ctx.lineTo(e.x-e.size, e.y-e.size); ctx.lineTo(e.x+e.size, e.y-e.size); ctx.fill();
              } else if (e.type === 'square') {
                ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
              } else if (e.type === 'pentagon') {
                ctx.beginPath();
                for(let k=0; k<5; k++){
                  const a = (Math.PI*2*k)/5 - Math.PI/2;
                  const px = e.x + Math.cos(a)*e.size;
                  const py = e.y + Math.sin(a)*e.size;
                  if(k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
                }
                ctx.fill();
                ctx.fillStyle='#fdf4ff'; ctx.beginPath(); ctx.arc(e.x, e.y, e.size/2, 0, Math.PI*2); ctx.fill();
              } else {
                ctx.beginPath(); ctx.arc(e.x, e.y, e.size, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle='#fff'; ctx.fillRect(e.x-2, e.y-8, 4, 16); ctx.fillRect(e.x-8, e.y-2, 16, 4);
              }
            });

            // Enemy Bullets
            eBulletsRef.current.forEach(b => { ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill(); });

            // Particles
            particlesRef.current.forEach(pt => {
              ctx.fillStyle = pt.color; ctx.globalAlpha = pt.life;
              ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
            });

            requestRef.current = requestAnimationFrame(loop);
          };

          requestRef.current = requestAnimationFrame(loop);
          return () => {
            window.removeEventListener('resize', resize);
            canvas.removeEventListener('mousemove', onMouseMove);
            canvas.removeEventListener('touchmove', onTouchMove);
            canvas.removeEventListener('touchstart', onTouchStart);
            if (requestRef.current) cancelAnimationFrame(requestRef.current);
          };
        }, [gameState, difficulty, onGameOver, onScoreUpdate]);

        useEffect(() => {
          if (gameState === 'playing') resetGame();
        }, [gameState]);

        return <canvas ref={canvasRef} style={{ display: 'block', width: '100%', height: '100%' }} />;
      };

      // --- ICONS ---
      const IconWrapper = ({ children, size=24, color='currentColor' }) => (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">{children}</svg>
      );
      const Shield = ({size, color}) => <IconWrapper size={size} color={color}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></IconWrapper>;
      const Target = ({size, color}) => <IconWrapper size={size} color={color}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></IconWrapper>;
      const Zap = ({size, color}) => <IconWrapper size={size} color={color}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconWrapper>;
      const Skull = ({size, color}) => <IconWrapper size={size} color={color}><path d="M12 2c-3.87 0-7 3.13-7 7 0 2.25 1.07 4.25 2.74 5.57.85 1.57.9 3.25.9 4.43h6.72c0-1.18.05-2.86.9-4.43A7.002 7.002 0 0 0 19 9c0-3.87-3.13-7-7-7z"/><path d="M15 14a2 2 0 1 0-2 2"/></IconWrapper>;
      const ChevronRight = ({size, color}) => <IconWrapper size={size} color={color}><polyline points="9 18 15 12 9 6"/></IconWrapper>;
      const Play = ({size, fill}) => <svg width={size||24} height={size||24} viewBox="0 0 24 24" fill={fill||"none"} stroke={fill?"none":"currentColor"} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
      const RotateCcw = ({size}) => <IconWrapper size={size}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconWrapper>;
      const MenuIcon = ({size}) => <IconWrapper size={size}><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></IconWrapper>;

      // --- APP COMPONENT ---
      function App() {
        const [gameState, setGameState] = useState('menu');
        const [score, setScore] = useState(0);
        const [highScore, setHighScore] = useState(0);
        const [difficulty, setDifficulty] = useState('NORMAL');

        const handleGameOver = useCallback((finalScore) => {
          setGameState('gameover');
          setScore(finalScore);
          if (finalScore > highScore) setHighScore(finalScore);
        }, [highScore]);

        const handleScoreUpdate = useCallback((s) => setScore(s), []);

        const getThemeColor = () => {
          if (difficulty === 'EASY' || difficulty === 'NORMAL') return '#3b82f6';
          if (difficulty === 'HARD') return '#9333ea';
          return '#ef4444';
        };

        const getSubTitle = () => {
          if (difficulty === 'EASY') return 'Readiness: Green';
          if (difficulty === 'NORMAL') return 'Readiness: Standard';
          if (difficulty === 'HARD') return 'Warning: High Hostility';
          return 'DANGER: EXTREME HAZARD';
        };

        const getDiffStyle = (lvl) => {
          if (difficulty !== lvl) return {};
          if (lvl === 'HARD') return { borderColor: '#9333ea', backgroundColor: '#faf5ff' };
          if (lvl === 'IMPOSSIBLE') return { borderColor: '#ef4444', backgroundColor: '#fef2f2' };
          return { borderColor: '#3b82f6', backgroundColor: '#eff6ff' };
        };

        return (
          <div className="full-screen">
            <div className="full-screen z-0">
              <GameEngine 
                gameState={gameState} 
                difficulty={difficulty}
                onGameOver={handleGameOver}
                onScoreUpdate={handleScoreUpdate}
              />
            </div>

            {/* HUD */}
            {gameState === 'playing' && (
              <div className="hud-container z-10 pointer-events-none">
                <div className="hud-panel">
                  <span className="text-label">Score</span>
                  <div className="text-score">{score.toLocaleString()}</div>
                </div>
                <div className="hud-badge">
                  <span className="text-label" style={{marginBottom:0}}>{DIFFICULTIES[difficulty].label}</span>
                </div>
              </div>
            )}

            {/* MENU */}
            {gameState === 'menu' && (
              <div className="full-screen z-20 menu-overlay">
                <div className="menu-content">
                  <div className="icon-circle"><Target size={32} color={getThemeColor()}/></div>
                  <h1 className="title-text" style={{color: getThemeColor()}}>NEON TACTICAL</h1>
                  <p className="subtitle-text">{getSubTitle()}</p>
                  
                  <div className="difficulty-list">
                    {Object.keys(DIFFICULTIES).map(lvl => (
                      <button key={lvl} onClick={()=>setDifficulty(lvl)} className={`difficulty-btn ${difficulty===lvl?'selected':''}`} style={getDiffStyle(lvl)}>
                        <div className="diff-content">
                          {lvl==='EASY' && <Shield size={20} color={difficulty===lvl?'#3b82f6':'#94a3b8'}/>}
                          {lvl==='NORMAL' && <Target size={20} color={difficulty===lvl?'#3b82f6':'#94a3b8'}/>}
                          {lvl==='HARD' && <Zap size={20} color={difficulty===lvl?'#9333ea':'#94a3b8'}/>}
                          {lvl==='IMPOSSIBLE' && <Skull size={20} color={difficulty===lvl?'#ef4444':'#94a3b8'}/>}
                          <div className="diff-text-group">
                            <div className="diff-name">{DIFFICULTIES[lvl].label}</div>
                            <div className="diff-desc">{lvl==='EASY'?'Recruit':lvl==='NORMAL'?'Veteran':lvl==='HARD'?'Elite':'Legend'}</div>
                          </div>
                        </div>
                        {difficulty===lvl && <ChevronRight size={20} color={getThemeColor()}/>}
                      </button>
                    ))}
                  </div>

                  <button onClick={()=>setGameState('playing')} className="btn-primary" style={{backgroundColor: difficulty==='IMPOSSIBLE'?'#ef4444':difficulty==='HARD'?'#9333ea':'#0f172a'}}>
                    <span>ENGAGE</span><Play size={20} fill="currentColor"/>
                  </button>
                  {highScore>0 && <div style={{marginTop:'1.5rem', color:'#94a3b8'}}>HIGH SCORE: <span style={{color:'#1e293b'}}>{highScore.toLocaleString()}</span></div>}
                </div>
              </div>
            )}

            {/* GAME OVER */}
            {gameState === 'gameover' && (
              <div className="full-screen z-30 menu-overlay">
                <div className="menu-content">
                  <h2 className="gameover-title">MIA</h2>
                  <p className="subtitle-text">Mission Failed</p>
                  <div className="gameover-card">
                    <div className="text-label">Final Score</div>
                    <div className="text-score" style={{fontSize:'2.5rem'}}>{score.toLocaleString()}</div>
                    <div className="score-row">
                      <span className="text-label" style={{marginBottom:0}}>Best</span>
                      <span style={{fontSize:'1.125rem', fontWeight:700, color:'#475569'}}>{Math.max(score, highScore).toLocaleString()}</span>
                    </div>
                  </div>
                  <div style={{display:'flex', flexDirection:'column', gap:'1rem', width:'100%'}}>
                    <button onClick={()=>setGameState('playing')} className="btn-primary"><RotateCcw size={20}/><span>RETRY</span></button>
                    <button onClick={()=>setGameState('menu')} className="btn-secondary"><MenuIcon size={16}/><span>RETURN TO BASE</span></button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      // --- RENDER ---
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>